/* $Id$ */
/** @file
 * BS3Kit - bs3-cpu-decoding-1, 32-bit C code.
 */

/*
 * Copyright (C) 2007-2016 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 *
 * The contents of this file may alternatively be used under the terms
 * of the Common Development and Distribution License Version 1.0
 * (CDDL) only, as it comes in the "COPYING.CDDL" file of the
 * VirtualBox OSE distribution, in which case the provisions of the
 * CDDL are applicable instead of those of the GPL.
 *
 * You may elect to license modified versions of this file under the
 * terms and conditions of either the GPL or the CDDL or both.
 */


/*********************************************************************************************************************************
*   Header Files                                                                                                                 *
*********************************************************************************************************************************/
#include <bs3kit.h>
#include <iprt/asm-amd64-x86.h>


/*********************************************************************************************************************************
*   Structures and Typedefs                                                                                                      *
*********************************************************************************************************************************/
/**
 * Simple test.
 */
typedef struct CPUDECODE1TST
{
    uint16_t fFlags;
    uint8_t  cbOpcodes;
    uint8_t  abOpcodes[20];
    uint8_t  cbUd;
} CPUDECODE1TST;
typedef CPUDECODE1TST BS3_FAR *PCPUDECODE1TST;

#define P_CS  X86_OP_PRF_CS
#define P_SS  X86_OP_PRF_SS
#define P_DS  X86_OP_PRF_DS
#define P_ES  X86_OP_PRF_ES
#define P_FS  X86_OP_PRF_FS
#define P_GS  X86_OP_PRF_GS
#define P_OZ  X86_OP_PRF_SIZE_OP
#define P_AZ  X86_OP_PRF_SIZE_ADDR
#define P_LK  X86_OP_PRF_LOCK
#define P_RZ  X86_OP_PRF_REPZ
#define P_RN  X86_OP_PRF_REPNZ

#define RM_EAX_EAX              ((3 << X86_MODRM_MOD_SHIFT) | (X86_GREG_xAX <<  X86_MODRM_REG_SHIFT) | (X86_GREG_xAX))
#define RM_EAX_DEREF_EBX        ((0 << X86_MODRM_MOD_SHIFT) | (X86_GREG_xAX <<  X86_MODRM_REG_SHIFT) | (X86_GREG_xBX))
#define RM_EAX_DEREF_EBX_DISP8  ((1 << X86_MODRM_MOD_SHIFT) | (X86_GREG_xAX <<  X86_MODRM_REG_SHIFT) | (X86_GREG_xBX))
#define RM_EAX_DEREF_EBX_DISP32 ((2 << X86_MODRM_MOD_SHIFT) | (X86_GREG_xAX <<  X86_MODRM_REG_SHIFT) | (X86_GREG_xBX))
#define RM_EAX_SIB              ((0 << X86_MODRM_MOD_SHIFT) | (X86_GREG_xAX <<  X86_MODRM_REG_SHIFT) | 4)
#define RM_EAX_SIB_DISP8        ((1 << X86_MODRM_MOD_SHIFT) | (X86_GREG_xAX <<  X86_MODRM_REG_SHIFT) | 4)
#define RM_EAX_SIB_DISP32       ((2 << X86_MODRM_MOD_SHIFT) | (X86_GREG_xAX <<  X86_MODRM_REG_SHIFT) | 4)

#define SIB_EBX_X1_NONE         ((0 << X86_SIB_SCALE_SHIFT) | (4            <<  X86_SIB_INDEX_SHIFT) | (X86_GREG_xBX))
#define SIB_EBX_X2_NONE         ((1 << X86_SIB_SCALE_SHIFT) | (4            <<  X86_SIB_INDEX_SHIFT) | (X86_GREG_xBX))
#define SIB_EBX_X4_NONE         ((2 << X86_SIB_SCALE_SHIFT) | (4            <<  X86_SIB_INDEX_SHIFT) | (X86_GREG_xBX))
#define SIB_EBX_X8_NONE         ((3 << X86_SIB_SCALE_SHIFT) | (4            <<  X86_SIB_INDEX_SHIFT) | (X86_GREG_xBX))

#define F_486   UINT16_C(0x0000)
#define F_SSE2  UINT16_C(0x0001)
#define F_SSE3  UINT16_C(0x0002)
#define F_SSE42 UINT16_C(0x0004)
#define F_MOVBE UINT16_C(0x0080)
#define F_CBUD  UINT16_C(0x4000)
#define F_UD    UINT16_C(0x8000)
#define F_OK    UINT16_C(0x0000)


/**
 * This is an exploratory testcase.  It tries to figure out how exactly the
 * different Intel and AMD CPUs implements SSE and similar instructions that
 * uses the size, repz, repnz and lock prefixes in the encoding.
 */
CPUDECODE1TST const g_aSimpleTests[] =
{
    /*
     *  fFlags, cbUd, cbOpcodes, abOpcodes
     */
#if 0
    /* Using currently undefined 0x0f 0x7a sequences. */
    {           F_UD, 3,               { 0x0f, 0x7a, RM_EAX_EAX, } },
    {           F_UD, 3+1,       { P_LK, 0x0f, 0x7a, RM_EAX_EAX, } },
    {           F_UD, 3+1,       { P_RN, 0x0f, 0x7a, RM_EAX_EAX, } },
    {           F_UD, 3+1,       { P_RZ, 0x0f, 0x7a, RM_EAX_EAX, } },
    {           F_UD, 3+2, { P_LK, P_LK, 0x0f, 0x7a, RM_EAX_EAX, } },
    {           F_UD, 4,               { 0x0f, 0x7a, RM_EAX_DEREF_EBX_DISP8, 0 } },
    {           F_UD, 4+1,       { P_LK, 0x0f, 0x7a, RM_EAX_DEREF_EBX_DISP8, 0 } },
    {           F_UD, 4+1,       { P_RN, 0x0f, 0x7a, RM_EAX_DEREF_EBX_DISP8, 0 } },
    {           F_UD, 4+1,       { P_RZ, 0x0f, 0x7a, RM_EAX_DEREF_EBX_DISP8, 0 } },
    {           F_UD, 4+2, { P_LK, P_LK, 0x0f, 0x7a, RM_EAX_DEREF_EBX_DISP8, 0 } },
    {           F_UD, 7,               { 0x0f, 0x7a, RM_EAX_DEREF_EBX_DISP32, 0, 0, 0, 0 } },
    {           F_UD, 7+1,       { P_LK, 0x0f, 0x7a, RM_EAX_DEREF_EBX_DISP32, 0, 0, 0, 0 } },
    {           F_UD, 7+1,       { P_RN, 0x0f, 0x7a, RM_EAX_DEREF_EBX_DISP32, 0, 0, 0, 0 } },
    {           F_UD, 7+1,       { P_RZ, 0x0f, 0x7a, RM_EAX_DEREF_EBX_DISP32, 0, 0, 0, 0 } },
    {           F_UD, 7+2, { P_LK, P_LK, 0x0f, 0x7a, RM_EAX_DEREF_EBX_DISP32, 0, 0, 0, 0 } },
#endif
#if 0
    /* Ditto for currently undefined sequence: 0x0f 0x7b */
    {           F_UD, 3,               { 0x0f, 0x7b, RM_EAX_EAX, } },
    {           F_UD, 3+1,       { P_LK, 0x0f, 0x7b, RM_EAX_EAX, } },
    {           F_UD, 3+1,       { P_RN, 0x0f, 0x7b, RM_EAX_EAX, } },
    {           F_UD, 3+1,       { P_RZ, 0x0f, 0x7b, RM_EAX_EAX, } },
    {           F_UD, 3+2, { P_LK, P_LK, 0x0f, 0x7b, RM_EAX_EAX, } },
#endif
#if 1
    /* Ditto for currently undefined sequence: 0x0f 0x24 */
    {           F_UD, 3,               { 0x0f, 0x24, RM_EAX_EAX, } },
    {           F_UD, 3+1,       { P_LK, 0x0f, 0x24, RM_EAX_EAX, } },
    {           F_UD, 3+1,       { P_RN, 0x0f, 0x24, RM_EAX_EAX, } },
    {           F_UD, 3+1,       { P_RZ, 0x0f, 0x24, RM_EAX_EAX, } },
    {           F_UD, 3+2, { P_LK, P_LK, 0x0f, 0x24, RM_EAX_EAX, } },
#endif
#if 0
    /* The XADD instruction has empty lines for 66, f3 and f2 prefixes.
       AMD doesn't do anything special for XADD Ev,Gv as the intel table would indicate. */
    {    F_486 | F_OK,  3,             { 0x0f, 0xc1, RM_EAX_EAX, } },
    {    F_486 | F_OK,  4,       { P_OZ, 0x0f, 0xc1, RM_EAX_EAX, } },
    {    F_486 | F_OK,  4,       { P_RN, 0x0f, 0xc1, RM_EAX_EAX, } },
    {    F_486 | F_OK,  5, { P_OZ, P_RN, 0x0f, 0xc1, RM_EAX_EAX, } },
    {    F_486 | F_OK,  5, { P_RN, P_OZ, 0x0f, 0xc1, RM_EAX_EAX, } },
    {    F_486 | F_OK,  4,       { P_RZ, 0x0f, 0xc1, RM_EAX_EAX, } },
    {    F_486 | F_OK,  5, { P_OZ, P_RZ, 0x0f, 0xc1, RM_EAX_EAX, } },
    {    F_486 | F_OK,  5, { P_RZ, P_OZ, 0x0f, 0xc1, RM_EAX_EAX, } },
#endif
#if 0
    /* The movnti instruction is confined to the unprefixed lined in the intel manuals. Check how the other lines work. */
    {   F_SSE2 | F_UD,  3,             { 0x0f, 0xc3, RM_EAX_EAX, } },        /* invalid - reg,reg */
    {   F_SSE2 | F_OK,  3,             { 0x0f, 0xc3, RM_EAX_DEREF_EBX, } },
    {   F_SSE2 | F_UD,  4,       { P_OZ, 0x0f, 0xc3, RM_EAX_DEREF_EBX, } },  /* invalid */
    {   F_SSE2 | F_UD,  4,       { P_RN, 0x0f, 0xc3, RM_EAX_DEREF_EBX, } },  /* invalid */
    {   F_SSE2 | F_UD,  4,       { P_RZ, 0x0f, 0xc3, RM_EAX_DEREF_EBX, } },  /* invalid */
    {   F_SSE2 | F_UD,  4,       { P_LK, 0x0f, 0xc3, RM_EAX_DEREF_EBX, } },  /* invalid */
    {   F_SSE2 | F_UD,  5, { P_RZ, P_LK, 0x0f, 0xc3, RM_EAX_DEREF_EBX, } },  /* invalid */
#endif
#if 0
    /* The lddqu instruction requires a 0xf2 prefix, intel only lists 0x66 and empty
       prefix for it.  Check what they really mean by that*/
    {   F_SSE3 | F_UD,  4,            { P_RZ, 0x0f, 0xf0, RM_EAX_EAX, } },          /* invalid - reg, reg  */
    {   F_SSE3 | F_OK,  4,            { P_RZ, 0x0f, 0xf0, RM_EAX_DEREF_EBX, } },
    {   F_SSE3 | F_OK,  5,      { P_RZ, P_RZ, 0x0f, 0xf0, RM_EAX_DEREF_EBX, } },
    {   F_SSE3 | F_UD,  3,      {             0x0f, 0xf0, RM_EAX_DEREF_EBX, } },
    {   F_SSE3 | F_UD,  4,      {       P_RN, 0x0f, 0xf0, RM_EAX_DEREF_EBX, } },
    {   F_SSE3 | F_UD,  4,      {       P_OZ, 0x0f, 0xf0, RM_EAX_DEREF_EBX, } },
    {   F_SSE3 | F_UD,  4,      {       P_LK, 0x0f, 0xf0, RM_EAX_DEREF_EBX, } },
    {   F_SSE3 | F_UD,  5,      { P_RZ, P_RN, 0x0f, 0xf0, RM_EAX_DEREF_EBX, } },
    {   F_SSE3 | F_OK,  5,      { P_RZ, P_OZ, 0x0f, 0xf0, RM_EAX_DEREF_EBX, } }, // AMD,why?
    {   F_SSE3 | F_UD,  5,      { P_RZ, P_LK, 0x0f, 0xf0, RM_EAX_DEREF_EBX, } },
    {   F_SSE3 | F_OK,  5,      { P_RN, P_RZ, 0x0f, 0xf0, RM_EAX_DEREF_EBX, } },
    {   F_SSE3 | F_OK,  5,      { P_OZ, P_RZ, 0x0f, 0xf0, RM_EAX_DEREF_EBX, } },
    {   F_SSE3 | F_UD,  5,      { P_LK, P_RZ, 0x0f, 0xf0, RM_EAX_DEREF_EBX, } },
    {   F_SSE3 | F_OK,  5,      { P_OZ, P_RZ, 0x0f, 0xf0, RM_EAX_DEREF_EBX, } },
    {   F_SSE3 | F_OK,  6,{ P_OZ, P_RN, P_RZ, 0x0f, 0xf0, RM_EAX_DEREF_EBX, } },
#endif
#if 0
    {   F_SSE2 | F_OK,  3,            { 0x0f, 0x7e, RM_EAX_EAX, } },
    {   F_SSE2 | F_OK,  4,      { P_OZ, 0x0f, 0x7e, RM_EAX_EAX, } },
    {   F_SSE2 | F_UD,  5,{ P_RZ, P_OZ, 0x0f, 0x7e, RM_EAX_EAX, } }, // WTF?
    {   F_SSE2 | F_UD,  5,{ P_OZ, P_RZ, 0x0f, 0x7e, RM_EAX_EAX, } },
    {   F_SSE2 | F_OK,  5,{ P_RN, P_OZ, 0x0f, 0x7e, RM_EAX_EAX, } },
    {   F_SSE2 | F_OK,  4,      { P_RN, 0x0f, 0x7e, RM_EAX_EAX, } },
    {   F_SSE2 | F_UD,  4,      { P_RZ, 0x0f, 0x7e, RM_EAX_EAX, } },
#endif
/** @todo crc32 / movbe  */
};

void DecodeEdgeTest(void)
{
    /*
     * Allocate and initialize a page pair
     */
    uint8_t BS3_FAR *pbPages;
    pbPages  = Bs3MemGuardedTestPageAlloc(BS3MEMKIND_FLAT32);
    if (pbPages)
    {
        unsigned        i;
        BS3REGCTX       Ctx;
        BS3TRAPFRAME    TrapFrame;

        Bs3MemZero(&Ctx, sizeof(Ctx));
        Bs3MemZero(&TrapFrame, sizeof(TrapFrame));

        ASMSetCR0((ASMGetCR0() & ~(X86_CR0_EM | X86_CR0_TS)) | X86_CR0_MP);
        ASMSetCR4(ASMGetCR4() | X86_CR4_OSFXSR);

        Bs3RegCtxSaveEx(&Ctx, BS3_MODE_CODE_32, 512);
        Ctx.rbx.u64 = (uintptr_t)pbPages;

        for (i = 0; i < RT_ELEMENTS(g_aSimpleTests); i++)
        {
            unsigned const cbOpcodes = g_aSimpleTests[i].cbOpcodes;
            uint16_t const fFlags    = g_aSimpleTests[i].fFlags;
            unsigned cb;
            /** @todo check if supported. */

            /*
             * Place the instruction exactly at the page boundrary and proceed to
             * move it across it and check that we get #PFs then.
             */
            cb = cbOpcodes;
            while (cb >= 1)
            {
                unsigned const   cErrorsBefore = Bs3TestSubErrorCount();
                uint8_t BS3_FAR *pbRip = &pbPages[X86_PAGE_SIZE - cb];
                Bs3MemCpy(pbRip, &g_aSimpleTests[i].abOpcodes[0], cb);
                Bs3RegCtxSetRipCsFromFlat(&Ctx, (uintptr_t)pbRip);
                Bs3TrapSetJmpAndRestore(&Ctx, &TrapFrame);
#if 1
                Bs3TestPrintf("\ni=%d cb=%#x (cbOpcodes=%#x fFlags=%#x)\n", i, cb, cbOpcodes, fFlags);
//                Bs3TrapPrintFrame(&TrapFrame);
#endif
                if (cb >= cbOpcodes && (g_aSimpleTests[i].fFlags & F_UD))
                {
                    if (TrapFrame.bXcpt != X86_XCPT_UD)
                        Bs3TestFailedF("i=%d cb=%d cbOp=%d fFlags=%#x: expected #UD got %#x at %RX32\n",
                                       i, cb, cbOpcodes, fFlags, TrapFrame.bXcpt, TrapFrame.Ctx.rip.u32);
                }
                else if (cb < cbOpcodes)
                {
                    if (TrapFrame.bXcpt != X86_XCPT_PF)
                        Bs3TestFailedF("i=%d cb=%d cbOp=%d fFlags=%#x: expected #PF (on) got %#x at %RX32\n",
                                       i, cb, cbOpcodes, fFlags, TrapFrame.bXcpt, TrapFrame.Ctx.rip.u32);
                    else if (TrapFrame.Ctx.rip.u32 != (uintptr_t)pbRip)
                        Bs3TestFailedF("i=%d cb=%d cbOp=%d fFlags=%#x: expected #PF rip of %p (on) got %#RX32\n",
                                       i, cb, cbOpcodes, fFlags, pbRip, TrapFrame.Ctx.rip.u32);
                }
                else
                {
                    if (TrapFrame.bXcpt != X86_XCPT_PF)
                        Bs3TestFailedF("i=%d cb=%d cbOp=%d fFlags=%#x: expected #PF (after) got %#x at %RX32\n",
                                       i, cb, cbOpcodes, fFlags, TrapFrame.bXcpt, TrapFrame.Ctx.rip.u32);
                    else if (TrapFrame.Ctx.rip.u32 != (uintptr_t)&pbPages[X86_PAGE_SIZE])
                        Bs3TestFailedF("i=%d cb=%d cbOp=%d fFlags=%#x: expected #PF rip of %p (after) got %#RX32\n",
                                       i, cb, cbOpcodes, fFlags, &pbPages[X86_PAGE_SIZE], TrapFrame.Ctx.rip.u32);
                }
                if (Bs3TestSubErrorCount() != cErrorsBefore)
                {
                    Bs3TestPrintf("  %.*Rhxs", cb, &g_aSimpleTests[i].abOpcodes[0]);
                    if (cb < cbOpcodes)
                        Bs3TestPrintf("[%.*Rhxs]", cbOpcodes - cb, &g_aSimpleTests[i].abOpcodes[cb]);
                    Bs3TestPrintf("\n");
                }

                /* next */
                cb--;
            }
        }

        Bs3MemGuardedTestPageFree(pbPages);
    }
    else
        Bs3TestFailed("Failed to allocate two pages!\n");

    /*
     * Test instruction sequences.
     */


}


/**
 * Undefined opcode test.
 */
typedef struct CPUDECODE1UDTST
{
    /** Type of undefined opcode decoding logic - UD_T_XXX. */
    uint8_t     enmType;
    /** Core opcodes length. */
    uint8_t     cbOpcodes;
    /** Core opcodes. */
    uint8_t     abOpcodes[5];
    /** UD_F_XXX. */
    uint8_t     fFlags;
} CPUDECODE1UDTST;
typedef CPUDECODE1UDTST const BS3_FAR *PCCPUDECODE1UDTST;

#define UD_T_EXACT          0
#define UD_T_MODRM          1
#define UD_T_MODRM_IMM8     2

#define UD_F_ANY_PFX 0
#define UD_F_NOT_NO_PFX     UINT8_C(0x01)  /**< Must have some kind of prefix to be \#UD. */
#define UD_F_NOT_OZ_PFX     UINT8_C(0x02)  /**< Skip the size prefix. */
#define UD_F_NOT_RZ_PFX     UINT8_C(0x04)  /**< Skip the REPZ prefix. */
#define UD_F_NOT_RN_PFX     UINT8_C(0x08)  /**< Skip the REPNZ prefix. */
#define UD_F_NOT_LK_PFX     UINT8_C(0x10)  /**< Skip the LOCK prefix. */
#define UD_F_3BYTE_ESC      UINT8_C(0x20)  /**< Unused 3 byte escape table. Test all 256 entries */

CPUDECODE1UDTST const g_aUdTest[] =
{
    /* Two byte opcodes. */
    {  UD_T_EXACT, 2, { 0x0f, 0x04 }, UD_F_ANY_PFX },
    {  UD_T_EXACT, 2, { 0x0f, 0x0a }, UD_F_ANY_PFX },
    {  UD_T_EXACT, 2, { 0x0f, 0x0c }, UD_F_ANY_PFX },
    {  UD_T_EXACT, 2, { 0x0f, 0x0e }, UD_F_ANY_PFX },
    {  UD_T_EXACT, 2, { 0x0f, 0x0f }, UD_F_ANY_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x13 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x14 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x15 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x16 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX | UD_F_NOT_RN_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x17 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    /** @todo figure when 0f 019 and 0f 0c-0f were made into NOPs. */
    {  UD_T_EXACT, 2, { 0x0f, 0x24 }, UD_F_ANY_PFX },
    {  UD_T_EXACT, 2, { 0x0f, 0x25 }, UD_F_ANY_PFX },
    {  UD_T_EXACT, 2, { 0x0f, 0x26 }, UD_F_ANY_PFX },
    {  UD_T_EXACT, 2, { 0x0f, 0x27 }, UD_F_ANY_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x28 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x29 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x2b }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x2e }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x2f }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_EXACT, 2, { 0x0f, 0x36 }, UD_F_ANY_PFX },
    {  UD_T_MODRM,      3, { 0x0f, 0x39, 0x00 }, UD_F_3BYTE_ESC | UD_F_ANY_PFX }, /* Three byte escape table, just unused.  */
    {  UD_T_MODRM_IMM8, 3, { 0x0f, 0x3b, 0x00 }, UD_F_3BYTE_ESC | UD_F_ANY_PFX }, /* Three byte escape table, just unused.  */
    {  UD_T_MODRM,      3, { 0x0f, 0x3c, 0x00 }, UD_F_3BYTE_ESC | UD_F_ANY_PFX }, /* Three byte escape table, just unused.  */
    {  UD_T_MODRM,      3, { 0x0f, 0x3d, 0x00 }, UD_F_3BYTE_ESC | UD_F_ANY_PFX }, /* Three byte escape table, just unused.  */
    {  UD_T_MODRM_IMM8, 3, { 0x0f, 0x3e, 0x00 }, UD_F_3BYTE_ESC | UD_F_ANY_PFX }, /* Three byte escape table, just unused.  */
    {  UD_T_MODRM_IMM8, 3, { 0x0f, 0x3f, 0x00 }, UD_F_3BYTE_ESC | UD_F_ANY_PFX }, /* Three byte escape table, just unused.  */
    {  UD_T_MODRM, 2, { 0x0f, 0x50 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x52 }, UD_F_NOT_NO_PFX | UD_F_NOT_RN_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x53 }, UD_F_NOT_NO_PFX | UD_F_NOT_RN_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x54 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x55 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x56 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x57 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x5b }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX | UD_F_NOT_RN_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x60 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x61 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x62 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x63 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x64 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x65 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x66 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x67 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x68 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x69 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x6a }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x6b }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x6c }, UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x6d }, UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x6e }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x6f }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX | UD_F_NOT_RN_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x74 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x75 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x76 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    /* 0f 77: WTF? OZ, RZ and RN are all empty in the intel tables and LK isn't metnioned at all: */
    {  UD_T_MODRM, 2, { 0x0f, 0x77 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX | UD_F_NOT_RZ_PFX | UD_F_NOT_RN_PFX | UD_F_NOT_LK_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x78 }, UD_F_NOT_NO_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x79 }, UD_F_NOT_NO_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x7a }, UD_F_ANY_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x7b }, UD_F_ANY_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x7c }, UD_F_NOT_OZ_PFX | UD_F_NOT_RZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x7d }, UD_F_NOT_OZ_PFX | UD_F_NOT_RZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x7e }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX | UD_F_NOT_RN_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0x7f }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX | UD_F_NOT_RN_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xa6 }, UD_F_ANY_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xa7 }, UD_F_ANY_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xb8 }, UD_F_NOT_RN_PFX },
    /** @todo f3 0f bb rm and f2 0f bb rm does stuff on skylake even if their are blank in intel and AMD tables! */
    //{  UD_T_MODRM, 2, { 0x0f, 0xbb }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    /** @todo AMD tables indicates that f2 0f bc rm is invalid, but on skylake it works differently (BSF?)  */
    {  UD_T_MODRM, 2, { 0x0f, 0xbc }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX | UD_F_NOT_RN_PFX /* figure: */ | UD_F_NOT_RZ_PFX },
    /** @todo AMD tables indicates that f3 0f bc rm is invalid, but on skylake it works differently (BSR?) */
    {  UD_T_MODRM, 2, { 0x0f, 0xbd }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX | UD_F_NOT_RN_PFX /* figure: */ | UD_F_NOT_RZ_PFX },
    /* Note! Intel incorrectly states that XADD (0f c0 and 0f c1) are sensitive to OZ, RN and RZ.  AMD and skylake hw disagrees. */
    {  UD_T_MODRM, 2, { 0x0f, 0xc3 }, UD_F_NOT_NO_PFX },
    {  UD_T_MODRM_IMM8, 2, { 0x0f, 0xc4 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM_IMM8, 2, { 0x0f, 0xc5 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM_IMM8, 2, { 0x0f, 0xc6 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xd0 }, UD_F_NOT_OZ_PFX | UD_F_NOT_RZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xd1 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xd2 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xd3 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xd4 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xd5 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xd6 }, UD_F_NOT_OZ_PFX | UD_F_NOT_RZ_PFX | UD_F_NOT_RN_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xd7 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xd8 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xd9 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xda }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xdb }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xdc }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xdd }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xde }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xdf }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xe0 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xe1 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xe2 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xe3 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xe4 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xe5 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xe6 }, UD_F_NOT_OZ_PFX | UD_F_NOT_RZ_PFX | UD_F_NOT_RN_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xe7 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xe8 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xe9 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xea }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xeb }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xec }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xed }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xee }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xef }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xf0 }, UD_F_NOT_RZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xf1 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xf2 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xf3 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xf4 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xf5 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xf6 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xf7 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xf8 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xf9 }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xfa }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xfb }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xfc }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xfd }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xfe }, UD_F_NOT_NO_PFX | UD_F_NOT_OZ_PFX },
    {  UD_T_MODRM, 2, { 0x0f, 0xff }, UD_F_ANY_PFX },
};


void DecodeUdEdgeTest(PCCPUDECODE1UDTST paTests, unsigned cTests)
{
    /*
     * Allocate and initialize a page pair
     */
    uint8_t BS3_FAR *pbPages;
    pbPages  = Bs3MemGuardedTestPageAlloc(BS3MEMKIND_FLAT32);
    if (pbPages)
    {
        unsigned        iTest;
        BS3REGCTX       Ctx;
        BS3REGCTX       ExpectCtx;
        BS3TRAPFRAME    TrapFrame;
        uint32_t        iStep;

        Bs3MemZero(&Ctx, sizeof(Ctx));
        Bs3MemZero(&ExpectCtx, sizeof(ExpectCtx));
        Bs3MemZero(&TrapFrame, sizeof(TrapFrame));

        /* Enable SSE. */
        ASMSetCR0((ASMGetCR0() & ~(X86_CR0_EM | X86_CR0_TS)) | X86_CR0_MP);
        ASMSetCR4(ASMGetCR4() | X86_CR4_OSFXSR);

        /* Create a test context. */
        Bs3RegCtxSaveEx(&Ctx, BS3_MODE_CODE_32, 512);
        Ctx.rbx.u = (uintptr_t)pbPages;
        Ctx.rcx.u = (uintptr_t)pbPages;
        Ctx.rdx.u = (uintptr_t)pbPages;
        Ctx.rax.u = (uintptr_t)pbPages;
        Ctx.rbp.u = (uintptr_t)pbPages;
        Ctx.rsi.u = (uintptr_t)pbPages;
        Ctx.rdi.u = (uintptr_t)pbPages;

        Bs3MemCpy(&ExpectCtx, &Ctx, sizeof(ExpectCtx));
        ExpectCtx.rflags.u32 |= X86_EFL_RF;

        /* Loop thru the tests. */
        iStep = g_usBs3TestStep = 0;
        for (iTest = 0; iTest < cTests; iTest++)
        {
            typedef struct CPUDECODE1UDSEQ
            {
                uint8_t cb;
                uint8_t ab[10];
                uint8_t fIncompatible;
            } CPUDECODE1UDSEQ;
            typedef CPUDECODE1UDSEQ const BS3_FAR *PCCPUDECODE1UDSEQ;

            static CPUDECODE1UDSEQ const s_aPrefixes[] =
            {
                { 0, { 0    },              UD_F_NOT_NO_PFX },
                { 1, { P_OZ },              UD_F_NOT_OZ_PFX },
                { 1, { P_RZ },              UD_F_NOT_RZ_PFX },
                { 1, { P_RN },              UD_F_NOT_RN_PFX },
                { 1, { P_LK },              UD_F_NOT_LK_PFX },
                { 2, { P_OZ, P_OZ },        UD_F_NOT_OZ_PFX | UD_F_NOT_OZ_PFX },
                { 2, { P_RZ, P_OZ },        UD_F_NOT_RZ_PFX | UD_F_NOT_OZ_PFX },
                { 2, { P_RN, P_OZ },        UD_F_NOT_RN_PFX | UD_F_NOT_OZ_PFX },
                { 2, { P_LK, P_OZ },        UD_F_NOT_LK_PFX | UD_F_NOT_OZ_PFX },
                { 2, { P_OZ, P_RZ },        UD_F_NOT_OZ_PFX | UD_F_NOT_RZ_PFX },
                { 2, { P_RZ, P_RZ },        UD_F_NOT_RZ_PFX | UD_F_NOT_RZ_PFX },
                { 2, { P_RN, P_RZ },        UD_F_NOT_RN_PFX | UD_F_NOT_RZ_PFX },
                { 2, { P_LK, P_RZ },        UD_F_NOT_LK_PFX | UD_F_NOT_RZ_PFX },
                { 2, { P_OZ, P_RN },        UD_F_NOT_OZ_PFX | UD_F_NOT_RN_PFX },
                { 2, { P_RZ, P_RN },        UD_F_NOT_RZ_PFX | UD_F_NOT_RN_PFX },
                { 2, { P_RN, P_RN },        UD_F_NOT_RN_PFX | UD_F_NOT_RN_PFX },
                { 2, { P_LK, P_RN },        UD_F_NOT_LK_PFX | UD_F_NOT_RN_PFX },
                { 2, { P_OZ, P_LK },        UD_F_NOT_OZ_PFX | UD_F_NOT_LK_PFX },
                { 2, { P_RZ, P_LK },        UD_F_NOT_RZ_PFX | UD_F_NOT_LK_PFX },
                { 2, { P_RN, P_LK },        UD_F_NOT_RN_PFX | UD_F_NOT_LK_PFX },
                { 2, { P_LK, P_LK },        UD_F_NOT_LK_PFX | UD_F_NOT_LK_PFX },
            };

            static CPUDECODE1UDSEQ const s_aExact[] = { { 0, { 0 }, 0 } };
            static CPUDECODE1UDSEQ const s_aModRm[] =
            {
                { 1, { RM_EAX_EAX, },                                       0 },
                { 2, { RM_EAX_DEREF_EBX_DISP8, 0 },                         0 },
                { 5, { RM_EAX_DEREF_EBX_DISP32, 0, 0, 0, 0 },               0 },
                { 2, { RM_EAX_SIB, SIB_EBX_X1_NONE, },                      0 },
                { 3, { RM_EAX_SIB_DISP8,  SIB_EBX_X1_NONE, 0 },             0 },
                { 6, { RM_EAX_SIB_DISP32, SIB_EBX_X1_NONE, 0, 0, 0, 0 },    0 },
            };
            static CPUDECODE1UDSEQ const s_aModRmImm8[] =
            {
                { 1 + 1, { RM_EAX_EAX, 0x11 },                                      0 },
                { 2 + 1, { RM_EAX_DEREF_EBX_DISP8, 0, 0x11 },                       0 },
                { 5 + 1, { RM_EAX_DEREF_EBX_DISP32, 0, 0, 0, 0, 0x11 },             0 },
                { 2 + 1, { RM_EAX_SIB, SIB_EBX_X1_NONE, 0x11 },                     0 },
                { 3 + 1, { RM_EAX_SIB_DISP8,  SIB_EBX_X1_NONE, 0, 0x11 },           0 },
                { 6 + 1, { RM_EAX_SIB_DISP32, SIB_EBX_X1_NONE, 0, 0, 0, 0, 0x11 },  0 },
            };
            unsigned            iPrefix;
            unsigned            cSuffixes;
            PCCPUDECODE1UDSEQ   paSuffixes;
            unsigned const      cSubTabEntries = paTests[iTest].fFlags & UD_F_3BYTE_ESC ? 256 : 1;
            unsigned            cImmEntries    = 1;

            /*
             * Skip if implemented.
             */

            /*
             * Produce a number of opcode sequences by varying the prefixes and
             * ModR/M parts.  Each opcode sequence is then treated to the edge test.
             */
            switch (paTests[iTest].enmType)
            {
                case UD_T_EXACT:
                    cSuffixes   = RT_ELEMENTS(s_aExact);
                    paSuffixes  = s_aExact;
                    break;
                case UD_T_MODRM:
                    cSuffixes   = RT_ELEMENTS(s_aModRm);
                    paSuffixes  = s_aModRm;
                    break;
                case UD_T_MODRM_IMM8:
                    cSuffixes   = RT_ELEMENTS(s_aModRmImm8);
                    paSuffixes  = s_aModRmImm8;
                    cImmEntries = 256;
                    break;
                default:
                    Bs3TestPrintf("#%u: enmType=%d\n", paTests[iTest].enmType);
                    continue;
            }

            for (iPrefix = 0; iPrefix < RT_ELEMENTS(s_aPrefixes); iPrefix++)
                if (!(s_aPrefixes[iPrefix].fIncompatible & paTests[iTest].fFlags))
                {
                    unsigned iSubTab;
                    unsigned cbOpcodesLead;
                    uint8_t  abOpcodes[32];

                    Bs3MemCpy(&abOpcodes[0], &s_aPrefixes[iPrefix].ab[0], s_aPrefixes[iPrefix].cb);
                    cbOpcodesLead  = s_aPrefixes[iPrefix].cb;
                    Bs3MemCpy(&abOpcodes[cbOpcodesLead], &paTests[iTest].abOpcodes[0], paTests[iTest].cbOpcodes);
                    cbOpcodesLead += paTests[iTest].cbOpcodes;

                    for (iSubTab = 0; iSubTab < cSubTabEntries; iSubTab++)
                    {
                        unsigned iSuffix;

                        if (cSubTabEntries > 1)
                            abOpcodes[cbOpcodesLead - 1] = iSubTab;

                        for (iSuffix = 0; iSuffix < cSuffixes; iSuffix++)
                            if (!(paSuffixes[iSuffix].fIncompatible & paTests[iTest].fFlags))
                            {
                                unsigned const  cbOpcodes    = cbOpcodesLead + paSuffixes[iSuffix].cb;
                                unsigned        cbOpcodesMin = 1;
                                unsigned        iImm;
                                Bs3MemCpy(&abOpcodes[cbOpcodesLead], paSuffixes[iSuffix].ab, paSuffixes[iSuffix].cb);

                                for (iImm = 0; iImm < cImmEntries; iImm++)
                                {
                                    unsigned cb;

                                    if (cImmEntries > 1)
                                        abOpcodes[cbOpcodes - 1] = iImm;

                                    /*
                                     * Do the edge thing.
                                     */
                                    cb = cbOpcodes;
                                    while (cb >= cbOpcodesMin)
                                    {
                                        uint8_t BS3_FAR *pbRip = &pbPages[X86_PAGE_SIZE - cb];
                                        uint8_t          bXcptExpected;

                                        Bs3RegCtxSetRipCsFromFlat(&Ctx, (uintptr_t)pbRip);
                                        ExpectCtx.rip = Ctx.rip;
                                        ExpectCtx.cs  = Ctx.cs;
                                        if (cb >= cbOpcodes)
                                        {
                                            ExpectCtx.cr2 = Ctx.cr2;
                                            bXcptExpected = X86_XCPT_UD;
                                        }
                                        else
                                        {
                                            ExpectCtx.cr2.u = (uintptr_t)&pbPages[X86_PAGE_SIZE];
                                            bXcptExpected = X86_XCPT_PF;
                                        }

                                        Bs3MemCpy(pbRip, &abOpcodes[0], cb);
                                        Bs3TrapSetJmpAndRestore(&Ctx, &TrapFrame);
#if 0
                                        Bs3TestPrintf("iTest=%d iPrefix=%d (%d/%#x) iSubTab=%d iSuffix=%d (%d/%#x) iImm=%d cb=%d cbOp=%d: %.*Rhxs\n",
                                                       iTest, iPrefix, s_aPrefixes[iPrefix].cb, s_aPrefixes[iPrefix].fIncompatible,
                                                       iSubTab, iSuffix, paSuffixes[iSuffix].cb, paSuffixes[iSuffix].fIncompatible, iImm,
                                                       cb, cbOpcodes,
                                                       cbOpcodes, abOpcodes);
#endif

                                        if (   !Bs3TestCheckRegCtxEx(&TrapFrame.Ctx, &ExpectCtx, 0 /*cbPcAdjust*/,
                                                                     0 /*cbSpAdjust*/, 0 /*fExtraEfl*/, "mode",  0)
                                            || TrapFrame.bXcpt != bXcptExpected)
                                        {
                                            Bs3TestFailedF("iTest=%d iPrefix=%d (%d/%#x) iSubTab=%u iSuffix=%d (%d/%#x) cb=%d cbOp=%d: %.*Rhxs\n",
                                                           iTest, iPrefix, s_aPrefixes[iPrefix].cb, s_aPrefixes[iPrefix].fIncompatible,
                                                           iSubTab, iSuffix, paSuffixes[iSuffix].cb, paSuffixes[iSuffix].fIncompatible,
                                                           cb, cbOpcodes,
                                                           cbOpcodes, abOpcodes);
                                            if (TrapFrame.bXcpt != bXcptExpected)
                                                Bs3TestFailedF("Expected bXcpt=%#x got %#x\n", bXcptExpected, TrapFrame.bXcpt);
                                            Bs3TrapPrintFrame(&TrapFrame);
                                            Bs3Shutdown();
                                        }

                                        /* next */
                                        g_usBs3TestStep++;
                                        iStep++;
                                        cb--;
                                    }

                                    /* For iImm > 0 only test cb == cbOpcode since the byte isn't included when cb < cbOpcode. */
                                    cbOpcodesMin = cbOpcodes;
                                }
                            }
                    }
                }
        }
        Bs3TestPrintf("%RI32 (%#RX32) test steps\n", iStep, iStep);

        Bs3MemGuardedTestPageFree(pbPages);
    }
    else
        Bs3TestFailed("Failed to allocate two pages!\n");
}




BS3_DECL(void) Main_pp32()
{
    Bs3TestInit("bs3-cpu-decoding-1");
    Bs3TestPrintf("g_uBs3CpuDetected=%#x\n", g_uBs3CpuDetected);

    //DecodeEdgeTest();
    Bs3TestSub("undefined opcodes");
    DecodeUdEdgeTest(g_aUdTest, RT_ELEMENTS(g_aUdTest));

    Bs3TestTerm();

    //for (;;) ASMHalt();
}

